#include "regex.h"

static const char * const insn_names[] = {
	"jump",
	"accept",
	"alt_first",
	"alt_second",
	"byte",
	"dfa_shortest",
	"dfa_longest",
	"capture_start",
	"capture_end",
	"capture_discard",
	"capture_backref",
	"assert_boundary",
	"assert_notboundary",
	"assert_start",
	"assert_end",
	"lookahead_positive",
	"lookahead_negative",
};

class regex::parser {
	static_assert(ARRAY_SIZE(insn_names) == regex::t_lookahead_negative+1);
	
public:
	// public so there's an autogenerated constructor
	regex* rgx;
	const uint8_t * end;
	bitarray captures;
	
private:
	enum nodetype_t {
		n_series,
		n_alternative,
		n_insn, // subtype is byte, dfa, capture, assert, or lookahead; no jump/accept/alternative
	};
	
	struct node_t {
		nodetype_t type;
		
		insn_t subtype; // valid only for type=insn (can't contain jump/accept/alt/noop)
		array<node_t> children; // valid for type=series, type=alternative, and subtype=lookahead (lookahead doesn't use its data)
		
		// these five correspond to *+?{} repeats
		uint32_t num_total_bodies = 1;
		uint32_t num_mandatory_bodies = 1;
		bool has_repeat = false;
		bool repeat_infinite = false;
		bool greedy = true;
		
		bool can_nfa; // False if it contains any capture, assertion, or lookahead.
	};
	
	// Returns *at unless that's a backslash.
	// If the input bits are nonempty, the new one will be or'd in.
	// single_char will be set to the single matching byte, or left unchanged if there's multiple.
	static const uint8_t * literal_chars(bitset<256>& bits, int& single_char, const uint8_t * at, const uint8_t * end)
	{
		static const uint8_t simple_backslashes[256] = {
			0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			' ', '!', '"', '#', '$', '%', '&', '\'','(', ')', '*', '+', ',', '-', '.', '/',
			0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   ':', ';', '<', '=', '>', '?',
			'@', 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   '[', '\\',']', '^', '_',
			'`', 0,   '\b',0,   0,   0,   '\f',0,   0,   0,   0,   0,   0,   0,   '\n',0,
			0,   0,   '\r',0,   '\t',0,   '\v',0,   0,   0,   0,   '{', '|', '}', '~', 0,
			128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		};
		
		if (at == end)
			return nullptr;
		if (*at != '\\')
		{
			single_char = *at;
			bits[single_char] = true;
			return at+1;
		}
		
		if (at+1 == end)
			return nullptr;
		
		uint8_t head = at[1];
		if (simple_backslashes[head])
		{
			single_char = simple_backslashes[head];
			bits[single_char] = true;
			return at+2;
		}
		else if (head == '0')
		{
			if (at+2 < end && at[2] >= '0' && at[2] <= '9')
				return nullptr;
			single_char = '\0';
			bits[single_char] = true;
			return at+2;
		}
		else if (head == 'x')
		{
			if (at+2 >= end)
				return nullptr;
			
			uint8_t tmp;
			if (!fromstringhex_ptr((char*)at+2, (char*)at+4, tmp))
				return nullptr;
			single_char = tmp;
			bits[single_char] = true;
			return at+4;
		}
		else if (head == 'c')
		{
			if (at+2 == end)
				return nullptr;
			uint8_t tail = at[2]&~0x20;
			if (tail < 'A' || tail > 'Z')
				return nullptr;
			single_char = tail-'A';
			bits[single_char] = true;
			return at+3;
		}
		
		else if (head == 'd') bits |= CHAR_SET("0123456789");
		else if (head == 'D') bits |= ~CHAR_SET("0123456789");
		else if (head == 's') bits |= CHAR_SET("\t\n\v\f\r ");
		else if (head == 'S') bits |= ~CHAR_SET("\t\n\v\f\r ");
		else if (head == 'w') bits |= CHAR_SET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_");
		else if (head == 'W') bits |= ~CHAR_SET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_");
		else return nullptr;
		return at+2;
	}
	
	// An atom is a single item that can be affected by *+? repeats.
	// \b is also parsed here, despite not being repeatable.
	// Repeats themselves are not handled here, that's the caller's job.
	const uint8_t * parse_atom(node_t& target, const uint8_t * at)
	{
		if (at == end)
			return nullptr;
		if (CHAR_SET("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F" // I'd like to ban \1 as a probable typo,
		             "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F" // but the JS spec says it's legal,
		             " !\"#%&',-/0123456789:;<=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~" // and \n is plausible
		             "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F" // it's also nontrivial to ban that in []
		             "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F" // and long regexes should use raw strings anyways
		             "\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF"
		             "\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF"
		             "\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF"
		             "\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF"
		             "\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF"
		             "\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF").contains(*at))
		{
			target.type = n_insn;
			target.subtype = { t_byte, (uint32_t)rgx->bytes.size() };
			rgx->bytes.append()[*at] = true;
			return at+1;
		}
		else if (*at == '(')
		{
			if (at+2 >= end)
				return nullptr;
			if (at[1] == '?')
			{
				if (at+3 >= end)
					return nullptr;
				if (at[2] == ':')
				{
					at = parse_disjunction(target, at+3);
					if (!at || at == end || *at != ')')
						return nullptr;
					return at+1;
				}
				else if (at[2] == '=')
				{
					target.type = n_insn;
					target.subtype = { t_lookahead_positive };
					at = parse_disjunction(target.children.append(), at+3);
					if (!at || at == end || *at != ')')
						return nullptr;
					return at+1;
				}
				else if (at[2] == '!')
				{
					target.type = n_series;
					uint32_t n_prev_captures = rgx->num_captures;
					at = parse_disjunction(target.children.append({ n_insn, { t_lookahead_negative }}).children.append(), at+3);
					if (!at || at == end || *at != ')')
						return nullptr;
					for (uint32_t i=n_prev_captures;i<rgx->num_captures;i++)
					{
						target.children.append({ n_insn, { t_capture_discard, i }});
						this->captures[i] = false;
					}
					return at+1;
				}
				else return nullptr;
			}
			target.type = n_series;
			uint32_t capture_idx = rgx->num_captures++;
			target.children.append({ n_insn, { t_capture_start, capture_idx }});
			at = parse_disjunction(target.children.append(), at+1);
			target.children.append({ n_insn, { t_capture_end, capture_idx }});
			captures.set_resize(capture_idx, true);
			if (!at || at == end || *at != ')')
				return nullptr;
			return at+1;
		}
		else if (*at == '[')
		{
			at++;
			if (at == end)
				return nullptr;
			bool invert = false;
			target.type = n_insn;
			target.subtype = { t_byte, (uint32_t)rgx->bytes.size() };
			bitset<256>& bits = rgx->bytes.append();
			if (*at == '^')
			{
				invert = true;
				at++;
			}
			while (true)
			{
				if (!at || at == end)
					return nullptr;
				if (*at == ']')
					break;
				
				int range_start = -1;
				at = literal_chars(bits, range_start, at, end);
				if (!at)
					return nullptr;
				if (at+1 < end && at[0] == '-' && at[1] != ']')
				{
					if (range_start < 0)
						return nullptr;
					int range_end = -1;
					at = literal_chars(bits, range_end, at+1, end);
					if (!at)
						return nullptr;
					if (range_end < 0 || range_end < range_start)
						return nullptr;
					for (int i=range_start;i<=range_end;i++)
						bits[i] = true; // first and last have already been written, but whatever
				}
			}
			if (invert)
				bits = ~bits;
		}
		else if (*at == '\\')
		{
			if (at+1 == end)
				return nullptr;
			
			if (at[1] >= '1' && at[1] <= '9')
			{
				uint32_t capture_idx;
				at = (uint8_t*)fromstring_ptr_tail((char*)at+1, (char*)end, capture_idx);
				target.type = n_insn;
				target.subtype = { t_capture_backref, capture_idx };
				if (!captures.get_or(capture_idx, false))
					return nullptr;
				return at;
			}
			else if (at[1] == 'b')
			{
				target.type = n_insn;
				target.subtype = { t_assert_boundary };
			}
			else if (at[1] == 'B')
			{
				target.type = n_insn;
				target.subtype = { t_assert_notboundary };
			}
			else
			{
				target.type = n_insn;
				target.subtype = { t_byte, (uint32_t)rgx->bytes.size() };
				int discard;
				return literal_chars(rgx->bytes.append(), discard, at, end);
			}
			return at+2;
		}
		else if (*at == '^')
		{
			target.type = n_insn;
			target.subtype = { t_assert_start };
		}
		else if (*at == '$')
		{
			target.type = n_insn;
			target.subtype = { t_assert_end };
		}
		else if (*at == '.')
		{
			target.type = n_insn;
			target.subtype = { t_byte, (uint32_t)rgx->bytes.size() };
			rgx->bytes.append() = ~CHAR_SET("\r\n"); // no \u2028 \u2029 for you
		}
		else
			return nullptr;
		return at+1;
	}
	
	const uint8_t * parse_term(node_t& target, const uint8_t * at)
	{
		const uint8_t * start = at;
		at = parse_atom(target, at);
		if (!at || at == end || !CHAR_SET("*+?{").contains(*at))
			return at;
		if (start[0] == '^' || start[0] == '$') // can't repeat these
			return nullptr;
		if (start[0] == '\\' && (start[1] == 'b' || start[1] == 'B'))
			return nullptr;
		if (start[0] == '(' && start[1] == '?' && (start[2] == '=' || start[2] == '!'))
			return nullptr; // no need for bounds checks; if this was out of bounds, it'd be rejected in parse_atom
		
		uint32_t repeat_min;
		uint32_t repeat_max;
		if (*at == '*')
		{
			repeat_min = 0;
			repeat_max = UINT32_MAX;
			at++;
		}
		else if (*at == '+')
		{
			repeat_min = 1;
			repeat_max = UINT32_MAX;
			at++;
		}
		else if (*at == '?')
		{
			repeat_min = 0;
			repeat_max = 1;
			at++;
		}
		else if (*at == '{')
		{
			at++;
			
			if (at == end)
				return nullptr;
			// first number in {} is mandatory, {,5} is illegal
			at = (uint8_t*)fromstring_ptr_tail((char*)at, (char*)end, repeat_min);
			if (!at || at == end)
				return nullptr;
			
			if (*at == ',')
			{
				at++;
				if (at == end)
					return nullptr;
				if (*at == '}')
					repeat_max = UINT32_MAX;
				else
					at = (uint8_t*)fromstring_ptr_tail((char*)at, (char*)end, repeat_max);
				if (!at || *at != '}')
					return nullptr;
			}
			else if (*at == '}')
				repeat_max = repeat_min;
			else
				return nullptr;
			
			at++;
		}
		if (at < end && *at == '?')
		{
			at++;
			target.greedy = false;
		}
		else
			target.greedy = true;
		
		if (repeat_min > repeat_max)
			return nullptr;
		
		target.has_repeat = true;
		if (repeat_max == 0)
		{
			// I don't think anyone will do that, but it's technically legal
			target.num_total_bodies = 0;
			return at;
		}
		
		target.num_total_bodies = (repeat_max == UINT32_MAX ? max(repeat_min, 1) : repeat_max);
		target.num_mandatory_bodies = repeat_min;
		target.repeat_infinite = (repeat_max == UINT32_MAX);
		
		return at;
	}
	
	const uint8_t * parse_disjunction(node_t& target, const uint8_t * at)
	{
		bitarray init_captures = captures;
		bitarray new_captures = captures;
		size_t n_init_captures = rgx->num_captures;
		array<node_t>* target_seq = &target.children;
		target.type = n_series;
		while (true)
		{
			if (!at || at == end || *at == ')')
				break;
			
			if (*at == '|')
			{
				if (target.type == n_series)
				{
					target.type = n_alternative;
					node_t first_body = { n_series };
					first_body.children = std::move(target.children);
					target.children.reset();
					target.children.append(std::move(first_body));
				}
				
				node_t& next = target.children.append();
				next.type = n_series;
				target_seq = &next.children;
				
				at++;
				
				new_captures |= this->captures;
				this->captures = init_captures;
			}
			else
				at = parse_term(target_seq->append(), at);
		}
		
		if (init_captures != new_captures && target.type == n_alternative)
		{
			this->captures = new_captures;
			//node_t new_children = std::move();
			
			node_t real_disjunction = std::move(target);
			target.type = n_series;
			target.children.reset();
			
			for (size_t i=n_init_captures;i<rgx->num_captures;i++)
				target.children.append({ n_insn, { t_capture_discard, (uint32_t)i } });
			
			target.children.append(std::move(real_disjunction));
		}
		
		return at;
	}
	
	
	struct nfa_t {
	public:
		struct transition_t {
			bitset<256> bytes;
			bool immediate; // if true, all bytes must be false
			uint32_t target; // if target is 1, it's accepting
			
			bool operator==(const transition_t&) const = default;
		};
		struct state_t {
			// these aren't normal nfas; transition order is significant
			// a normal nfa can tell which strings match the regex, but I need to determine the order of the matches too
			// which means that despite the name, the order in 'transitions' is significant
			array<transition_t> transitions;
			bool deleted = false;
			
			bool accepting = false;
			bool accepts_sequel = false;
			
			bool operator==(const state_t&) const = default;
		};
		array<state_t> states;
		bool shortest_first;
		
		// If, for every transition in every state, the rules for this byte are same as the previous byte,
		// the corresponding bit is set here. (State 0 is always set.)
		bitset<256> unique_bytes;
		
		static bool tag_can_nfa(node_t& node)
		{
			bool can;
			if (node.type == n_insn)
			{
				can = (node.subtype.type == t_byte);
				for (node_t& child : node.children)
					tag_can_nfa(child);
			}
			else
			{
				can = true;
				for (node_t& child : node.children)
					can &= tag_can_nfa(child);
			}
			node.can_nfa = can;
			return can;
		}
		
	private:
		uint32_t new_state()
		{
			states.append();
			return states.size()-1;
		}
		void add_transition(uint32_t source, uint32_t target, bitset<256>& bytes, bool first)
		{
			transition_t& tr = (first ? states[source].transitions.insert(0) : states[source].transitions.append());
			tr.target = target;
			tr.bytes = bytes;
			tr.immediate = false;
		}
		void add_immediate_transition(uint32_t source, uint32_t target, bool first)
		{
			transition_t& tr = (first ? states[source].transitions.insert(0) : states[source].transitions.append());
			tr.target = target;
			tr.bytes = {};
			tr.immediate = true;
		}
		// Ignores has_repeat.
		void convert_single_node(regex* rgx, const node_t& node, uint32_t start_state, uint32_t accept_state)
		{
			if (node.type == n_insn)
			{
#ifndef ARLIB_OPT
				if (node.subtype.type != t_byte)
					abort();
#endif
				add_transition(start_state, accept_state, rgx->bytes[node.subtype.data], false);
			}
			else
			{
				create(rgx, node.children, node.type==n_alternative, start_state, accept_state);
			}
		}
		// Processes has_repeat.
		void convert_repeating_node(regex* rgx, const node_t& node, uint32_t start_state, uint32_t accept_state)
		{
			if (LIKELY(!node.has_repeat))
				return convert_single_node(rgx, node, start_state, accept_state);
			if (UNLIKELY(!node.num_total_bodies))
			{
				add_immediate_transition(start_state, accept_state, false);
				return;
			}
			
			uint32_t target = new_state();
			add_immediate_transition(start_state, target, false);
			uint32_t prev_end = target;
			for (size_t i=0;i<node.num_total_bodies;i++)
			{
				bool last = (i == node.num_total_bodies-1);
				uint32_t target = new_state();
				convert_single_node(rgx, node, prev_end, target);
				if (i >= node.num_mandatory_bodies)
					add_immediate_transition(prev_end, accept_state, !node.greedy);
				if (last && node.repeat_infinite)
					add_immediate_transition(target, prev_end, false);
				if (last && (node.num_mandatory_bodies == node.num_total_bodies || !node.repeat_infinite))
					add_immediate_transition(target, accept_state, !node.greedy);
				prev_end = target;
			}
		}
		void create(regex* rgx, arrayview<node_t> nodes, bool is_alternative, uint32_t start_state, uint32_t accept_state)
		{
			if (is_alternative)
			{
				for (const node_t& n : nodes)
				{
					uint32_t state = new_state();
					add_immediate_transition(start_state, state, false);
					convert_repeating_node(rgx, n, state, accept_state);
				}
			}
			else
			{
				uint32_t source = start_state;
				for (size_t i=0;i<nodes.size();i++)
				{
					uint32_t target;
					if (i == nodes.size()-1)
						target = accept_state;
					else
						target = new_state();
					convert_repeating_node(rgx, nodes[i], source, target);
					source = target;
				}
				if (!nodes.size())
					add_immediate_transition(start_state, accept_state, false);
			}
		}
		
	private:
		void flatten_immediates()
		{
			bool again = true;
			while (again)
			{
				again = false;
				for (size_t i=0;i<states.size();i++)
				{
					state_t& st = states[i];
					for (size_t j=0;j<st.transitions.size();j++)
					{
						transition_t& tr = st.transitions[j];
						if (!tr.immediate)
							st.accepts_sequel = true;
						else if (tr.target == 1)
							st.accepting = true;
						else if (tr.target == i)
							st.transitions.remove(j);
						else
						{
							st.transitions.insert_range(j+1, states[tr.target].transitions);
							st.transitions.remove(j);
							again = true;
						}
					}
				}
			}
		}
		void deduplicate()
		{
			bool again = true;
			while (again)
			{
				again = false;
				for (size_t i=0;i<states.size();i++)
				for (size_t j=i+1;j<states.size();j++)
				{
					if (!states[i].deleted && !states[j].deleted && states[i] == states[j])
					{
						again = true;
						states[j].deleted = true;
						for (state_t& st : states)
						for (transition_t& tr : st.transitions)
						{
							if (tr.target == j)
								tr.target = i;
						}
					}
				}
			}
		}
		// mostly exists to make debug output cleaner
		void delete_unreachable_states()
		{
			bitarray reachable;
			reachable.resize(states.size());
			array<uint32_t> todo;
			todo.append(0);
			while (todo)
			{
				uint32_t st = todo.pop_tail();
				if (!states[st].deleted)
				{
					for (transition_t& tr : states[st].transitions)
					{
						if (!reachable[tr.target])
						{
							reachable[tr.target] = true;
							todo.append(tr.target);
						}
					}
				}
			}
			
			for (size_t i=0;i<states.size();i++)
			{
				if (!reachable[i] && i >= 2)
					states[i].deleted = true;
			}
		}
		void compress_deleted_states()
		{
			array<uint32_t> new_ids;
			new_ids.resize(states.size());
			size_t num_valid_states = 0;
			for (size_t i=0;i<states.size();i++)
			{
				if (i >= 2 && states[i].deleted)
					new_ids[i] = 0;
				else
					new_ids[i] = num_valid_states++;
			}
			for (size_t i=0;i<states.size();i++)
			{
				if (i >= 2 && states[i].deleted)
				{
					states.remove(i);
					i--;
				}
				else
				{
					for (transition_t& tr : states[i].transitions)
					{
						tr.target = new_ids[tr.target];
					}
				}
			}
		}
	public:
		void create(regex* rgx, arrayview<node_t> nodes, bool is_alternative)
		{
			states.resize(2);
			states[1].accepting = true;
			add_immediate_transition(1, 1, false);
			create(rgx, nodes, is_alternative, 0, 1);
			
			flatten_immediates();
			deduplicate();
			delete_unreachable_states();
			compress_deleted_states();
		}
		
	private:
		struct ordering_data {
			bitarray visited_primaries;
			array<bitarray> visited_secondaries;
			bool found_secondary_shorter = false;
			bool found_secondary_longer = false;
		};
		void set_ordering_recurse(ordering_data& dat, uint32_t primary, bitarray secondaries)
		{
			for (size_t i=0;i<secondaries.size();i++)
			{
				if (dat.visited_secondaries[primary][i])
					secondaries[i] = false;
			}
			if (dat.visited_primaries[primary] && !secondaries.any())
				return;
			dat.visited_primaries[primary] = true;
			dat.visited_secondaries[primary] |= secondaries;
			
			array<transition_t>& trs = states[primary].transitions;
			for (size_t i=0;i<trs.size();i++)
			{
				if (trs[i].immediate)
				{
					for (size_t secondary : secondaries.true_idxs())
					{
						for (transition_t& s_tr : states[secondary].transitions)
						{
							if (s_tr.bytes.any())
								dat.found_secondary_longer = true;
						}
					}
					if (i >= 1 && !trs[i-1].immediate)
					{
						dat.found_secondary_shorter = true;
					}
				}
				else
				{
					bitarray new_secondaries;
					new_secondaries.resize(states.size());
					for (transition_t& tr : trs.skip(i+1))
					{
						if ((trs[i].bytes & tr.bytes).any())
							new_secondaries[tr.target] = true;
					}
					for (size_t secondary : secondaries.true_idxs())
					{
						for (transition_t& tr : states[secondary].transitions)
						{
							if ((trs[i].bytes & tr.bytes).any())
								new_secondaries[tr.target] = true;
						}
						if (states[primary].accepts_sequel && states[secondary].accepting)
						{
							dat.found_secondary_shorter = true;
						}
					}
					set_ordering_recurse(dat, trs[i].target, std::move(new_secondaries));
					if (i >= 1 && trs[i-1].immediate)
					{
						dat.found_secondary_longer = true;
					}
				}
			}
		}
	public:
		bool set_ordering()
		{
			ordering_data dat;
			dat.visited_primaries.resize(states.size());
			dat.visited_secondaries.resize(states.size());
			for (size_t i=0;i<states.size();i++)
				dat.visited_secondaries[i].resize(states.size());
			set_ordering_recurse(dat, 0, {});
			
			if (dat.found_secondary_shorter && dat.found_secondary_longer)
				return false;
			
			// if both are legal, prefer shortest first
			shortest_first = !dat.found_secondary_shorter;
			return true;
		}
		
	private:
		uint32_t convert_to_dfa_recurse(dfa_t& dfa, map<bitarray, uint32_t>& seen, bitarray in_states)
		{
			uint32_t create_state = seen.size();
			uint32_t dfa_state = seen.get_create(in_states, create_state);
			if (dfa_state == create_state)
			{
				dfa.transitions.append();
				
				size_t n_set = 0;
				uint32_t next_state KNOWN_INIT(0);
				
				for (size_t by : unique_bytes.true_idxs())
				{
					while (n_set < by)
						dfa.transitions[dfa_state].next[n_set++] = next_state;
					
					bitarray new_states;
					new_states.resize(states.size());
					bool any = false;
					bool accepting = false;
					
					for (size_t i : in_states.true_idxs())
					{
						for (transition_t& tr : states[i].transitions)
						{
							if (tr.bytes[by])
							{
								if (states[tr.target].accepting)
									accepting = true;
								if (states[tr.target].accepts_sequel)
								{
									new_states[tr.target] = true;
									any = true;
								}
							}
						}
					}
					if (any)
						next_state = convert_to_dfa_recurse(dfa, seen, new_states);
					else
						next_state = 0x7FFFFFFF;
					if (accepting)
						next_state |= 0x80000000;
				}
				while (n_set < 256)
					dfa.transitions[dfa_state].next[n_set++] = next_state;
			}
			return dfa_state;
		}
	public:
		insntype_t convert_to_dfa(dfa_t& dfa)
		{
			// straightforward version:
			//unique_bytes[0] = true;
			//for (state_t& st : states)
			//for (transition_t& tr : st.transitions)
			//{
			//	for (size_t i=1;i<256;i++)
			//	{
			//		if (tr.bytes.get(i) != tr.bytes.get(i-1))
			//			unique_bytes[i] = true;
			//	}
			//}
			
			uint32_t ret[8] = { 1, 0, 0, 0, 0, 0, 0, 0 };
			static_assert(sizeof(unique_bytes) == sizeof(ret));
			
			for (state_t& st : states)
			for (transition_t& tr : st.transitions)
			{
				uint32_t tmp[8];
				memcpy(tmp, &tr.bytes, sizeof(tmp));
				ret[0] |= tmp[0] ^ (tmp[0]<<1);
				for (int i=1;i<8;i++)
					ret[i] |= tmp[i] ^ ((tmp[i]<<1) | (tmp[i-1]>>31));
			}
			memcpy(&unique_bytes, ret, sizeof(ret));
			
			map<bitarray, uint32_t> seen;
			bitarray in_states;
			in_states.resize(states.size());
			in_states[0] = true;
			convert_to_dfa_recurse(dfa, seen, in_states);
			dfa.init_state = states[0].accepting ? 0x80000000 : 0;
			return shortest_first ? t_dfa_shortest : t_dfa_longest;
		}
		
	private:
	public:
#ifndef _WIN32 // todo: enable these when my compiler shuts up about %zu
		void dump() const
		{
			for (size_t i=0;i<states.size();i++)
			{
				printf("state %zu: ", i);
				if (i == 1)
				{
					puts("accepting");
					continue;
				}
				if (states[i].deleted)
				{
					puts("deleted");
					continue;
				}
				arrayview<transition_t> trs = states[i].transitions;
				for (size_t j=0;j<trs.size();j++)
				{
					if (j >= 1) printf(", ");
					if (trs[j].immediate)
						printf("(immediate)");
					else
						dump_byte(trs[j].bytes);
					printf(" -> %u", trs[j].target);
				}
				puts("");
			}
			if (shortest_first)
				puts("shortest first");
			else
				puts("longest first");
		}
#endif
	};
	
	
	size_t try_convert_sequence_to_nfa(node_t& node, size_t start, size_t end)
	{
		if (start+1 == end)
		{
			try_convert_node_to_nfa(node.children[start]);
			return end;
		}
		
		nfa_t nfa;
		nfa.create(rgx, node.children.slice(start, end-start), node.type==n_alternative);
		
		if (nfa.set_ordering())
		{
			while (end-1 > start)
			{
				node.children.remove(end-1);
				end--;
			}
			uint32_t idx = rgx->dfas.size();
			insntype_t insn = nfa.convert_to_dfa(rgx->dfas.append());
			node.children[start] = { n_insn, { insn, idx } };
		}
		else
		{
			// if converting that fragment to NFA is ambiguous, delete the last node and try again
			try_convert_node_to_nfa(node.children[end-1]);
			return try_convert_sequence_to_nfa(node, start, end-1) + 1;
		}
		return end;
	}
	void try_convert_node_to_nfa(node_t& node)
	{
		if (node.type == n_insn)
		{
			for (node_t& ch : node.children)
				try_convert_node_to_nfa(ch);
			// if it's a byte instruction, just leave it
		}
		else
		{
			size_t start = 0;
			while (true)
			{
				while (start < node.children.size() && !node.children[start].can_nfa)
				{
					try_convert_node_to_nfa(node.children[start]);
					start++;
				}
				if (start == node.children.size())
					break;
				size_t end = start;
				while (end < node.children.size() && node.children[end].can_nfa)
					end++;
				
				start = try_convert_sequence_to_nfa(node, start, end);
			}
		}
	}
	
	void optimize_to_nfas(node_t& node)
	{
		nfa_t::tag_can_nfa(node);
		try_convert_node_to_nfa(node);
	}
	
	// Ignores repeat count.
	void to_insns_single(node_t& node)
	{
		if (node.type == n_series)
		{
			for (node_t& n : node.children)
				to_insns(n);
		}
		if (node.type == n_alternative)
		{
			size_t prev_start = 0;
			for (size_t i=0;i<node.children.size();i++)
			{
				node_t& n = node.children[i];
				bool first = (i == 0);
				bool last = (i == node.children.size()-1);
				
				size_t start = rgx->insns.size();
				if (!last)
					rgx->insns.append({ t_alternative_second });
				to_insns(n);
				if (prev_start)
					rgx->insns[prev_start].data = rgx->insns.size();
				if (!last)
				{
					prev_start = rgx->insns.size();
					rgx->insns.append({ t_jump });
					rgx->insns[start].data = rgx->insns.size();
				}
			}
		}
		if (node.type == n_insn)
		{
			if (node.children)
			{
				size_t start = rgx->insns.size();
				rgx->insns.append(node.subtype);
				for (node_t& n : node.children)
					to_insns(n);
				rgx->insns.append({ t_accept });
				rgx->insns[start].data = rgx->insns.size();
			}
			else
				rgx->insns.append(node.subtype);
		}
	}
	// Handles repeat count.
	void to_insns(node_t& node)
	{
		if (LIKELY(!node.has_repeat))
			return to_insns_single(node);
		
		size_t the_infinite_one = (node.repeat_infinite ? node.num_total_bodies-1 : SIZE_MAX);
		
		for (size_t i=0;i<node.num_total_bodies;i++)
		{
			if (i >= node.num_mandatory_bodies)
				rgx->insns.append(); // placeholder
			size_t insns_start = rgx->insns.size();
			to_insns_single(node);
			
			if (i == the_infinite_one)
				rgx->insns.append({ node.greedy ? t_alternative_first : t_alternative_second, (uint32_t)insns_start });
			if (i >= node.num_mandatory_bodies)
				rgx->insns[insns_start-1] = { node.greedy ? t_alternative_second : t_alternative_first, (uint32_t)rgx->insns.size() };
		}
	}
	
public:
	static bool parse(regex* rgx, cstring text)
	{
		rgx->reset();
		rgx->num_captures = 1;
		
		const uint8_t * start = text.bytes().ptr();
		const uint8_t * end = start + text.length();
		
		parser p { rgx, end };
		node_t target;
		const uint8_t * at = p.parse_disjunction(target, start);
		if (at != end)
		{
			rgx->set_fail();
			return false;
		}
		
		p.optimize_to_nfas(target);
		
		p.to_insns(target);
		rgx->insns.append({ t_accept });
		return true;
	}
	
private:
	void dump(const node_t& node) const { dump(rgx, node); }
	static void dump(regex* rgx, const node_t& node)
	{
		if (node.has_repeat)
		{
			printf("repeat (%u bodies, %u mandatory, %sfinite, %s) ",
				   node.num_total_bodies, node.num_mandatory_bodies, node.repeat_infinite ? "in" : "",
				   node.greedy ? "greedy" : "lazy");
		}
		if (node.type == n_insn)
			printf("insn %s", insn_names[node.subtype.type]);
		else
			printf("%s", node.type==n_series ? "series" : "alternative");
		if (node.type == n_insn && node.subtype.type == t_byte)
		{
			printf(" ");
			dump_byte(rgx->bytes[node.subtype.data]);
		}
		if (node.children)
		{
			printf(" {\n");
			for (const node_t& ch : node.children)
			{
				dump(rgx, ch);
			}
			printf("}");
		}
		printf("\n");
	}
};

bool regex::parse(cstring rgx)
{
	if (parser::parse(this, rgx))
	{
		optimize();
		return true;
	}
	else
	{
		set_fail();
		return false;
	}
}

void regex::optimize()
{
	bool again = true;
	while (again)
	{
		again = false;
		for (size_t i=0;i<insns.size();i++)
		{
			if (insns[i].type == t_jump && (insns[insns[i].data].type == t_jump || insns[insns[i].data].type == t_accept))
			{
				insns[i] = insns[insns[i].data];
				again = true;
			}
			else if (targets_another_insn(insns[i].type) && insns[insns[i].data].type == t_jump)
			{
				// parser doesn't emit alt/lookaround to jump, but why not
				insns[i].data = insns[insns[i].data].data;
				again = true;
			}
		}
	}
	
	// doubt this does anything, but it's harmless. Reduces memory use a little, I guess
	array<bitset<256>> new_bytes;
	for (size_t i=0;i<insns.size();i++)
	{
		if (insns[i].type == t_byte)
		{
			size_t idx = new_bytes.find(bytes[insns[i].data]);
			if (idx == (size_t)-1)
			{
				idx = new_bytes.size();
				new_bytes.append(bytes[insns[i].data]);
			}
			insns[i].data = idx;
		}
	}
	bytes = std::move(new_bytes);
	
	// rejected optimizations:
	// - delete unreachable instructions, after byte(none) or if only reachable by jump
	//     byte(none) is ultra rare, and jumps only come from | where the target is after the last branch, so no point
	// - deduplicate bytes in NFAs/DFAs; have a 256-byte table for each FA and shrink the transition tables to max(256b-table)+1
	//     probably helps NFAs, but not DFAs, and I never emit NFA instructions
	// - change re_text's caller; change to .search() and process the part before that, move $ handler to caller,
	//     and make .search() do an NFA with different start positions on the lone DFA contents
	//     probably more effort than it's worth, NFA is only faster if DFAed or if it eliminates backtracking
	//     ...maybe I could NFA the DFA with different start positions, then convert that to DFA
	//     would give trouble on abcd|bc, latter half will t_accept before former
	//     trying to solve that by running everything to finish will waste time on abcd|bc.*
	//     finishing every earlier-starting NFA state would work (have a map of DFA state -> original NFA states),
	//     but would be a huge wall of text and probably not accomplish much
	// - compress small NFAs to uint8
	//     tried it, gives a ~6% slowdown
}

class regex::matcher {
public:
	const regex * parent;
	const uint8_t * start;
	const uint8_t * end;
	
	regex::pair* result;
	const uint8_t * * capture_start;
	
	bool match(size_t state, const uint8_t * at)
	{
		while (true)
		{
			auto[type, data] = parent->insns[state++];
			switch (type)
			{
			case t_jump:
				state = data;
				break;
			case t_accept:
				result[0].end = (char*)at;
				return true;
			case t_alternative_first:
				if (match(data, at))
					return true;
				break;
			case t_alternative_second:
				if (match(state, at))
					return true;
				state = data;
				break;
			
			case t_byte:
				if (at == end)
					return false;
				if (!parent->bytes[data][*at++])
					return false;
				break;
			
			case t_dfa_shortest:
			{
				const dfa_t& dfa = parent->dfas[data];
				uint32_t dfa_state = dfa.init_state;
				while (true)
				{
					if (dfa_state & 0x80000000)
					{
						if (match(state, at))
							return true;
						dfa_state &= 0x7FFFFFFF;
					}
					if (dfa_state == 0x7FFFFFFF || at == end)
						return false;
					
					dfa_state = dfa.transitions[dfa_state].next[*at++];
				}
			}
			case t_dfa_longest:
			{
				const dfa_t& dfa = parent->dfas[data];
				uint32_t dfa_state = dfa.init_state;
				bitarray matches;
				size_t match_len = 0;
				while (true)
				{
					if (dfa_state & 0x80000000)
					{
						matches.set_resize(match_len, true);
						dfa_state &= 0x7FFFFFFF;
					}
					if (dfa_state == 0x7FFFFFFF || at+match_len == end)
						break;
					
					dfa_state = dfa.transitions[dfa_state].next[at[match_len++]];
				}
				for (ssize_t i=matches.size()-1;i>=0;i--)
				{
					if (matches[i] && match(state, at+i))
						return true;
				}
				return false;
			}
			
			case t_capture_start:
				capture_start[data] = at;
				break;
			case t_capture_end:
			{
				const char * prev_start = result[data].start;
				const char * prev_end = result[data].end;
				result[data].start = (char*)capture_start[data];
				result[data].end = (char*)at;
				if (match(state, at))
					return true;
				result[data].start = prev_start;
				result[data].end = prev_end;
				return false;
			}
			case t_capture_discard:
			{
				if (!result[data].start)
					break;
				const char * prev_start = result[data].start;
				const char * prev_end = result[data].end;
				result[data].start = nullptr;
				result[data].end = nullptr;
				if (match(state, at))
					return true;
				result[data].start = prev_start;
				result[data].end = prev_end;
				return false;
			}
			case t_capture_backref:
			{
				size_t len = result[data].end - result[data].start;
				if (at+len > end)
					return false;
				if (memcmp(at, result[data].start, len) != 0)
					return false;
				at += len;
				break;
			}
			
			case t_assert_boundary:
			case t_assert_notboundary:
			{
				uint8_t prev = (at == start ? '\0' : at[-1]);
				uint8_t next = (at == end ? '\0' : at[0]);
				auto chs = CHAR_SET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_");
				if ((chs.contains(prev) == chs.contains(next)) == (type == t_assert_boundary))
					return false;
				break;
			}
			case t_assert_start:
				if (at != start)
					return false;
				break;
			case t_assert_end:
				if (at != end)
					return false;
				break;
			
			case t_lookahead_positive:
				if (match(state, at) == true)
					state = data;
				else
					return false;
				break;
			case t_lookahead_negative:
				if (match(state, at) == false)
					state = data;
				else
					return false;
				break;
			
			default: __builtin_unreachable();
			}
		}
	}
};

void regex::match(pair* ret, void** tmp, const char * start, const char * at, const char * end) const
{
	ret[0].start = at;
	matcher m { this, (uint8_t*)start, (uint8_t*)end, ret, (const uint8_t**)tmp };
	if (!m.match(0, (uint8_t*)at))
	{
		// must wipe everything, not just result[0], to avoid bugs where (?!(a)) + "a" leaves trash
		memset(ret, 0, sizeof(pair)*num_captures);
	}
}

void regex::match_alloc(size_t num_captures, pair* ret, void** tmp, const char * start, const char * at, const char * end) const
{
	array<pair> ret2;
	array<void*> tmp2;
	ret2.resize(this->num_captures);
	tmp2.resize(this->num_captures);
	match(ret2.ptr(), tmp2.ptr(), start, at, end);
	memcpy(ret, ret2.ptr(), sizeof(pair)*num_captures);
}

string regex::replace(cstring str, const char * replacement) const
{
	pair store1[5] = {};
	array<pair> store2;
	void* store3[5];
	array<void*> store4;
	
	const char * start = str.ptr_raw();
	const char * end = str.ptr_raw_end();
	matcher m { this, (uint8_t*)start, (uint8_t*)end, store1, (const uint8_t**)store3 };
	if (num_captures > 5)
	{
		store2.resize(num_captures);
		store4.resize(num_captures);
		m.result = store2.ptr();
		m.capture_start = (const uint8_t**)store4.ptr();
	}
	
	string out;
	
	const char * iter = start;
	while (iter < end)
	{
		if (m.match(0, (uint8_t*)iter) && m.result[0].end > iter)
		{
			for (size_t i=0;replacement[i];i++)
			{
				if (replacement[i] == '\\')
				{
					int n = replacement[i+1]-'0';
					if (n < 0 || n > 9) abort();
					
					out += m.result[n].str();
					i++;
				}
				else
					out += replacement[i];
			}
			iter = m.result[0].end;
		}
		else
		{
			out += *iter;
			iter++;
		} 
	}
	return out;
}

#ifndef _WIN32 // todo: enable these when my compiler shuts up about %zu
void regex::dump(arrayview<insn_t> insns) const
{
	for (size_t i=0;i<insns.size();i++)
	{
		auto[type, data] = insns[i];
		printf("%zu %s %u", i, insn_names[type], data);
		if (type == t_byte)
		{
			printf(" ");
			dump_byte(bytes[data]);
		}
		puts("");
		if (type == t_dfa_shortest || type == t_dfa_longest)
		{
			if (dfas[data].init_state & 0x80000000)
				puts("  accepts empty");
			for (size_t st=0;st<dfas[data].transitions.size();st++)
			{
				const dfa_t::node_t& n = dfas[data].transitions[st];
				printf("  %zu: ", st);
				for (size_t by=0;by<256;by++)
				{
					size_t by1 = by;
					while (by+1 < 256 && n.next[by+1] == n.next[by])
						by++;
					dump_range(by1, by);
					
					uint32_t next_st_raw = n.next[by];
					int32_t next_st = next_st_raw & 0x7FFFFFFF;
					if (next_st == 0x7FFFFFFF)
						next_st = -1;
					printf(" -> %s%d", (next_st_raw&0x80000000) ? "A " : "", next_st);
					if (by != 255)
						printf(", ");
				}
				puts("");
			}
		}
	}
}
#endif
void regex::dump_byte(const bitset<256>& byte)
{
	int first_true = -1;
	for (int i=0;i<=256;i++)
	{
		if (i<256 && byte[i])
		{
			if (first_true == -1)
				first_true = i;
		}
		else
		{
			if (first_true != -1)
				dump_range(first_true, i-1);
			first_true = -1;
		}
	}
}
void regex::dump_range(uint8_t first, uint8_t last)
{
	if (last-first <= 3)
	{
		for (int i=first;i<=last;i++)
			dump_single_char(i);
	}
	else
	{
		dump_single_char(first);
		printf("-");
		dump_single_char(last);
	}
}
void regex::dump_single_char(uint8_t ch)
{
	if (ch <= ' ' || ch >= '\x7F' || ch == '-')
		printf("\\x%.2X", ch);
	else
		printf("%c", ch);
}
