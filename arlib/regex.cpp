#include "regex.h"
#include"test.h"
#include"os.h"

static const char * const insn_names[] = {
	"jump",
	"accept",
	"alt_first",
	"alt_second",
	"byte",
	"dfa_shortest",
	"dfa_longest",
	"capture_start",
	"capture_end",
	"capture_discard",
	"capture_backref",
	"assert_boundary",
	"assert_notboundary",
	"assert_start",
	"assert_end",
	"lookahead_positive",
	"lookahead_negative",
};

class regex::parser {
	static_assert(ARRAY_SIZE(insn_names) == regex::t_lookahead_negative+1);
	
public:
	// public so there's an autogenerated constructor
	regex* rgx;
	const uint8_t * end;
	bitarray captures;
	int recursion_count = 0;
	
public:
	// public because regex_search/required_substrs need it
	enum nodetype_t {
		n_series,
		n_alternative,
		n_insn, // subtype is byte, dfa, capture, assert, or lookahead; no jump/accept/alternative
	};
	
	struct node_t {
		nodetype_t type;
		
		insn_t subtype; // valid only for type=insn (can't contain jump/accept/alt/noop)
		array<node_t> children; // valid for type=series, type=alternative, and subtype=lookahead (lookahead doesn't use subtype.data)
		
		// these five correspond to *+?{} repeats
		uint32_t num_total_bodies = 1;
		uint32_t num_mandatory_bodies = 1;
		bool has_repeat = false;
		bool repeat_infinite = false;
		bool greedy = true;
		
		bool can_nfa; // False if it contains any capture, assertion, or lookahead.
	};
	
private:
	static const uint8_t * parse_error()
	{
		//debug_log_stack("a\n");
		return nullptr;
	}
	
	// Returns *at unless that's a backslash.
	// If the input bits are nonempty, the new one will be or'd in.
	// single_char will be set to the single matching byte, or left unchanged if there's multiple.
	static const uint8_t * literal_chars(bitset<256>& bits, int& single_char, const uint8_t * at, const uint8_t * end)
	{
		static const uint8_t simple_backslashes[256] = {
			0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			' ', '!', '"', '#', '$', '%', '&', '\'','(', ')', '*', '+', ',', '-', '.', '/',
			0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   ':', ';', '<', '=', '>', '?',
			'@', 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   '[', '\\',']', '^', '_',
			'`', 0,   '\b',0,   0,   0,   '\f',0,   0,   0,   0,   0,   0,   0,   '\n',0,
			0,   0,   '\r',0,   '\t',0,   '\v',0,   0,   0,   0,   '{', '|', '}', '~', 0,
			128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		};
		
		if (at == end)
			return parse_error();
		if (*at != '\\')
		{
			single_char = *at;
			bits[single_char] = true;
			return at+1;
		}
		
		if (at+1 == end)
			return parse_error();
		
		uint8_t head = at[1];
		if (simple_backslashes[head])
		{
			single_char = simple_backslashes[head];
			bits[single_char] = true;
			return at+2;
		}
		else if (head == '0')
		{
			if (at+2 < end && at[2] >= '0' && at[2] <= '9')
				return parse_error();
			single_char = '\0';
			bits[single_char] = true;
			return at+2;
		}
		else if (head == 'x')
		{
			if (at+4 > end)
				return parse_error();
			
			uint8_t tmp;
			if (!fromstringhex_ptr((char*)at+2, (char*)at+4, tmp))
				return parse_error();
			single_char = tmp;
			bits[single_char] = true;
			return at+4;
		}
		else if (head == 'c')
		{
			if (at+2 == end)
				return parse_error();
			uint8_t tail = at[2]&~0x20;
			if (tail < 'A' || tail > 'Z')
				return parse_error();
			single_char = tail-'A';
			bits[single_char] = true;
			return at+3;
		}
		
		else if (head == 'd') bits |= CHAR_SET("0123456789");
		else if (head == 'D') bits |= ~CHAR_SET("0123456789");
		else if (head == 's') bits |= CHAR_SET("\t\n\v\f\r ");
		else if (head == 'S') bits |= ~CHAR_SET("\t\n\v\f\r ");
		else if (head == 'w') bits |= CHAR_SET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_");
		else if (head == 'W') bits |= ~CHAR_SET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_");
		else return parse_error();
		return at+2;
	}
	
	// An atom is a single item that can be affected by *+? repeats.
	// \b is also parsed here, despite not being repeatable.
	// Repeats themselves are not handled here, that's the caller's job.
	const uint8_t * parse_atom(node_t& target, const uint8_t * at)
	{
		if (at == end)
			return parse_error();
		if (CHAR_SET("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F" // I'd like to ban \1 as a probable typo,
		             "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F" // but the JS spec says it's legal,
		             " !\"#%&',-/0123456789:;<=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~" // and \n is plausible
		             "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F" // it's also nontrivial to ban that in []
		             "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F" // and long regexes should use raw strings anyways
		             "\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF"
		             "\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF"
		             "\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF"
		             "\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF"
		             "\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF"
		             "\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF").contains(*at))
		{
			target.type = n_insn;
			target.subtype = { t_byte, (uint32_t)rgx->bytes.size() };
			rgx->bytes.append()[*at] = true;
			return at+1;
		}
		else if (*at == '(')
		{
			if (at+2 >= end)
				return parse_error();
			if (at[1] == '?')
			{
				if (at+3 >= end)
					return parse_error();
				if (at[2] == ':')
				{
					at = parse_disjunction(target, at+3);
					if (!at || at == end || *at != ')')
						return parse_error();
					return at+1;
				}
				else if (at[2] == '=')
				{
					target.type = n_insn;
					target.subtype = { t_lookahead_positive };
					at = parse_disjunction(target.children.append(), at+3);
					if (!at || at == end || *at != ')')
						return parse_error();
					return at+1;
				}
				else if (at[2] == '!')
				{
					target.type = n_series;
					uint32_t n_prev_captures = rgx->num_captures;
					at = parse_disjunction(target.children.append({ n_insn, { t_lookahead_negative }}).children.append(), at+3);
					if (!at || at == end || *at != ')')
						return parse_error();
					for (uint32_t i=n_prev_captures;i<rgx->num_captures;i++)
					{
						target.children.append({ n_insn, { t_capture_discard, i }});
						this->captures[i] = false;
					}
					return at+1;
				}
				else return parse_error();
			}
			target.type = n_series;
			uint32_t capture_idx = rgx->num_captures++;
			target.children.append({ n_insn, { t_capture_start, capture_idx }});
			at = parse_disjunction(target.children.append(), at+1);
			target.children.append({ n_insn, { t_capture_end, capture_idx }});
			this->captures.set_resize(capture_idx, true);
			if (!at || at == end || *at != ')')
				return parse_error();
			return at+1;
		}
		else if (*at == '[')
		{
			at++;
			if (at == end)
				return parse_error();
			bool invert = false;
			target.type = n_insn;
			target.subtype = { t_byte, (uint32_t)rgx->bytes.size() };
			bitset<256>& bits = rgx->bytes.append();
			if (*at == '^')
			{
				invert = true;
				at++;
			}
			while (true)
			{
				if (!at || at == end)
					return parse_error();
				if (*at == ']')
					break;
				
				int range_start = -1;
				at = literal_chars(bits, range_start, at, end);
				if (!at)
					return parse_error();
				if (at+1 < end && at[0] == '-' && at[1] != ']')
				{
					if (range_start < 0)
						return parse_error();
					int range_end = -1;
					at = literal_chars(bits, range_end, at+1, end);
					if (!at)
						return parse_error();
					if (range_end < 0 || range_end < range_start)
						return parse_error();
					for (int i=range_start;i<=range_end;i++)
						bits[i] = true; // first and last have already been written, but whatever
				}
			}
			if (invert)
				bits = ~bits;
		}
		else if (*at == '\\')
		{
			if (at+1 == end)
				return parse_error();
			
			if (at[1] >= '1' && at[1] <= '9')
			{
				uint32_t capture_idx;
				at = (uint8_t*)fromstring_ptr_tail((char*)at+1, (char*)end, capture_idx);
				target.type = n_insn;
				target.subtype = { t_capture_backref, capture_idx };
				if (!captures.get_or(capture_idx, false))
					return parse_error();
				return at;
			}
			else if (at[1] == 'b')
			{
				target.type = n_insn;
				target.subtype = { t_assert_boundary };
			}
			else if (at[1] == 'B')
			{
				target.type = n_insn;
				target.subtype = { t_assert_notboundary };
			}
			else
			{
				target.type = n_insn;
				target.subtype = { t_byte, (uint32_t)rgx->bytes.size() };
				int discard;
				return literal_chars(rgx->bytes.append(), discard, at, end);
			}
			return at+2;
		}
		else if (*at == '^')
		{
			target.type = n_insn;
			target.subtype = { t_assert_start };
		}
		else if (*at == '$')
		{
			target.type = n_insn;
			target.subtype = { t_assert_end };
		}
		else if (*at == '.')
		{
			target.type = n_insn;
			target.subtype = { t_byte, (uint32_t)rgx->bytes.size() };
			rgx->bytes.append() = ~CHAR_SET("\r\n"); // no \u2028 \u2029 for you
		}
		else
			return parse_error();
		return at+1;
	}
	
	const uint8_t * parse_term(node_t& target, const uint8_t * at)
	{
		const uint8_t * start = at;
		at = parse_atom(target, at);
		if (!at || at == end)
			return at;
		if (!at || at == end || !CHAR_SET("*+?{").contains(*at))
			return at;
		if (start[0] == '^' || start[0] == '$') // can't repeat these
			return parse_error();
		if (start[0] == '\\' && (start[1] == 'b' || start[1] == 'B'))
			return parse_error();
		if (start[0] == '(' && start[1] == '?' && (start[2] == '=' || start[2] == '!'))
			return parse_error(); // no need for bounds checks; if this was out of bounds, it'd be rejected in parse_atom
		
		uint32_t repeat_min;
		uint32_t repeat_max;
		if (*at == '*')
		{
			repeat_min = 0;
			repeat_max = UINT32_MAX;
			at++;
		}
		else if (*at == '+')
		{
			repeat_min = 1;
			repeat_max = UINT32_MAX;
			at++;
		}
		else if (*at == '?')
		{
			repeat_min = 0;
			repeat_max = 1;
			at++;
		}
		else if (*at == '{')
		{
			at++;
			
			if (at == end)
				return parse_error();
			// first number in {} is mandatory, {,5} is illegal
			at = (uint8_t*)fromstring_ptr_tail((char*)at, (char*)end, repeat_min);
			if (!at || at == end)
				return parse_error();
			
			if (*at == ',')
			{
				at++;
				if (at == end)
					return parse_error();
				if (*at == '}')
					repeat_max = UINT32_MAX;
				else
					at = (uint8_t*)fromstring_ptr_tail((char*)at, (char*)end, repeat_max);
				if (!at || *at != '}')
					return parse_error();
			}
			else if (*at == '}')
				repeat_max = repeat_min;
			else
				return parse_error();
			
			at++;
		}
		else __builtin_unreachable(); // it's one of the above four
		
		if (at < end && *at == '?')
		{
			at++;
			target.greedy = false;
		}
		else
			target.greedy = true;
		
		if (repeat_min > repeat_max)
			return parse_error();
		
		target.has_repeat = true;
		if (repeat_max == 0)
		{
			// I don't think anyone will do that, but it's technically legal
			target.num_total_bodies = 0;
			return at;
		}
		
		target.num_total_bodies = (repeat_max == UINT32_MAX ? max(repeat_min, 1) : repeat_max);
		target.num_mandatory_bodies = repeat_min;
		target.repeat_infinite = (repeat_max == UINT32_MAX);
		
		return at;
	}
	
	const uint8_t * parse_disjunction(node_t& target, const uint8_t * at)
	{
		bitarray init_captures = captures;
		bitarray new_captures = captures;
		size_t n_init_captures = rgx->num_captures;
		array<node_t>* target_seq = &target.children;
		target.type = n_series;
		while (true)
		{
			if (!at || at == end || *at == ')')
				break;
			
			if (*at == '|')
			{
				if (target.type == n_series)
				{
					target.type = n_alternative;
					node_t first_body = { n_series };
					first_body.children = std::move(target.children);
					target.children.reset();
					target.children.append(std::move(first_body));
				}
				
				node_t& next = target.children.append();
				next.type = n_series;
				target_seq = &next.children;
				
				at++;
				
				new_captures |= this->captures;
				this->captures = init_captures;
			}
			else
			{
				recursion_count++;
				if (recursion_count == 1000)
					return parse_error();
				at = parse_term(target_seq->append(), at);
				recursion_count--;
			}
		}
		
		if (init_captures != new_captures && target.type == n_alternative)
		{
			this->captures = new_captures;
			this->captures.resize(rgx->num_captures);
			//node_t new_children = std::move();
			
			node_t real_disjunction = std::move(target);
			target.type = n_series;
			target.children.reset();
			
			for (size_t i=n_init_captures;i<rgx->num_captures;i++)
				target.children.append({ n_insn, { t_capture_discard, (uint32_t)i } });
			
			target.children.append(std::move(real_disjunction));
		}
		
		return at;
	}
	
	
public:
	struct nfa_t {
	public:
		struct transition_t {
			bitset<256> bytes;
			bool immediate; // if true, all bytes must be false
			uint32_t target; // if target is 1, it's accepting
			
			bool operator==(const transition_t&) const = default;
		};
		struct state_t {
			// these aren't normal nfas; transition order is significant
			// a normal nfa can tell which strings match the regex, but I need to determine the order of the matches too
			// which means that despite the name, the order in 'transitions' is significant
			array<transition_t> transitions;
			bool deleted = false;
			
			bool accepting = false;
			bool accepts_sequel = false;
			
			bool operator==(const state_t&) const = default;
		};
		array<state_t> states;
		bool shortest_first;
		
		// If, for every transition in every state, the rules for this byte are same as the previous byte,
		// the corresponding bit is set here. (Bit 0 is always set.)
		bitset<256> unique_bytes;
		
		static bool tag_can_nfa(node_t& node)
		{
			bool can;
			if (node.type == n_insn)
			{
				can = (node.subtype.type == t_byte);
				for (node_t& child : node.children)
					tag_can_nfa(child);
			}
			else
			{
				can = true;
				for (node_t& child : node.children)
					can &= tag_can_nfa(child);
			}
			node.can_nfa = can;
			return can;
		}
		
	private:
		uint32_t new_state()
		{
			states.append();
			return states.size()-1;
		}
		void add_transition(uint32_t source, uint32_t target, const bitset<256>& bytes, bool first)
		{
			transition_t& tr = (first ? states[source].transitions.insert(0) : states[source].transitions.append());
			tr.target = target;
			tr.bytes = bytes;
			tr.immediate = false;
		}
		void add_immediate_transition(uint32_t source, uint32_t target, bool first)
		{
			transition_t& tr = (first ? states[source].transitions.insert(0) : states[source].transitions.append());
			tr.target = target;
			tr.bytes = {};
			tr.immediate = true;
		}
		// Ignores has_repeat.
		void convert_single_node(regex* rgx, const node_t& node, uint32_t start_state, uint32_t accept_state)
		{
			if (node.type == n_insn)
			{
#ifndef ARLIB_OPT
				if (node.subtype.type != t_byte)
					abort();
#endif
				add_transition(start_state, accept_state, rgx->bytes[node.subtype.data], false);
			}
			else
			{
				create(rgx, node.children, node.type==n_alternative, start_state, accept_state);
			}
		}
		// Processes has_repeat.
		void convert_repeating_node(regex* rgx, const node_t& node, uint32_t start_state, uint32_t accept_state)
		{
			if (LIKELY(!node.has_repeat))
				return convert_single_node(rgx, node, start_state, accept_state);
			if (UNLIKELY(!node.num_total_bodies))
			{
				add_immediate_transition(start_state, accept_state, false);
				return;
			}
			
			uint32_t target = new_state();
			add_immediate_transition(start_state, target, false);
			uint32_t prev_end = target;
			for (size_t i=0;i<node.num_total_bodies;i++)
			{
				bool last = (i == node.num_total_bodies-1);
				uint32_t target = new_state();
				convert_single_node(rgx, node, prev_end, target);
				if (i >= node.num_mandatory_bodies)
					add_immediate_transition(prev_end, accept_state, !node.greedy);
				if (last && node.repeat_infinite)
					add_immediate_transition(target, prev_end, false);
				if (last && (node.num_mandatory_bodies == node.num_total_bodies || !node.repeat_infinite))
					add_immediate_transition(target, accept_state, !node.greedy);
				prev_end = target;
			}
		}
		void create(regex* rgx, arrayview<node_t> nodes, bool is_alternative, uint32_t start_state, uint32_t accept_state)
		{
			if (is_alternative)
			{
				for (const node_t& n : nodes)
				{
					uint32_t state = new_state();
					add_immediate_transition(start_state, state, false);
					convert_repeating_node(rgx, n, state, accept_state);
				}
			}
			else
			{
				uint32_t source = start_state;
				for (size_t i=0;i<nodes.size();i++)
				{
					uint32_t target;
					if (i == nodes.size()-1)
						target = accept_state;
					else
						target = new_state();
					convert_repeating_node(rgx, nodes[i], source, target);
					source = target;
				}
				if (!nodes.size())
					add_immediate_transition(start_state, accept_state, false);
			}
		}
		
	private:
		void flatten_immediates()
		{
			bool again = true;
			while (again)
			{
				again = false;
				for (size_t i=0;i<states.size();i++)
				{
					state_t& st = states[i];
					for (size_t j=0;j<st.transitions.size();j++)
					{
						transition_t& tr = st.transitions[j];
						if (!tr.immediate)
							st.accepts_sequel = true;
						else if (tr.target == 1)
							st.accepting = true;
						else if (tr.target == i)
							st.transitions.remove(j);
						else
						{
							size_t target = tr.target;
							st.transitions.insert_range(j+1, states[target].transitions);
							st.transitions.remove(j);
							j += states[target].transitions.size() - 1; // skip the new ones, to avoid some infinite loops
							again = true;
						}
					}
				}
			}
		}
		void deduplicate()
		{
			bool again = true;
			while (again)
			{
				again = false;
				for (size_t i=0;i<states.size();i++)
				for (size_t j=i+1;j<states.size();j++)
				{
					if (!states[i].deleted && !states[j].deleted && states[i] == states[j])
					{
						again = true;
						states[j].deleted = true;
						for (state_t& st : states)
						{
							for (size_t k=0;k<st.transitions.size();k++)
							{
								if (st.transitions[k].target == j)
								{
									st.transitions[k].target = i;
									for (size_t l=0;l<k;l++)
									{
										if (st.transitions[l] == st.transitions[k])
										{
											// mostly shows up on silly regexes like a?a?a?a*, but why not
											st.transitions.remove(k);
											k--;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		// mostly exists to make debug output cleaner (reducing state count makes the NFA->DFA converter faster)
		void delete_unreachable_states()
		{
			bitarray reachable;
			reachable.resize(states.size());
			array<uint32_t> todo;
			todo.append(0);
			while (todo)
			{
				uint32_t st = todo.pop_tail();
				if (!states[st].deleted)
				{
					for (transition_t& tr : states[st].transitions)
					{
						if (!reachable[tr.target])
						{
							reachable[tr.target] = true;
							todo.append(tr.target);
						}
					}
				}
			}
			
			for (size_t i=0;i<states.size();i++)
			{
				if (!reachable[i] && i >= 2)
					states[i].deleted = true;
			}
		}
		void compress_deleted_states()
		{
			array<uint32_t> new_ids;
			new_ids.resize(states.size());
			size_t num_valid_states = 0;
			for (size_t i=0;i<states.size();i++)
			{
				if (i >= 2 && states[i].deleted)
					new_ids[i] = 0;
				else
					new_ids[i] = num_valid_states++;
			}
			for (size_t i=0;i<states.size();i++)
			{
				if (i >= 2 && states[i].deleted)
				{
					states.remove(i);
					i--;
				}
				else
				{
					for (transition_t& tr : states[i].transitions)
					{
						tr.target = new_ids[tr.target];
					}
				}
			}
		}
	public:
		void create(regex* rgx, arrayview<node_t> nodes, bool is_alternative)
		{
			states.resize(2);
			states[1].accepting = true;
			add_immediate_transition(1, 1, false); // todo: determine and document why this is necessary
			create(rgx, nodes, is_alternative, 0, 1);
			
			flatten_immediates();
			deduplicate();
			delete_unreachable_states();
			compress_deleted_states();
		}
		
	private:
		struct ordering_data {
			bitarray visited_primaries;
			array<bitarray> visited_secondaries;
			bool found_secondary_shorter = false;
			bool found_secondary_longer = false;
		};
		void set_ordering_recurse(ordering_data& dat, uint32_t primary, bitarray secondaries)
		{
			for (size_t i=0;i<secondaries.size();i++)
			{
				if (dat.visited_secondaries[primary][i])
					secondaries[i] = false;
			}
			if (dat.visited_primaries[primary] && !secondaries.any())
				return;
			dat.visited_primaries[primary] = true;
			dat.visited_secondaries[primary] |= secondaries;
			
			array<transition_t>& trs = states[primary].transitions;
			for (size_t i=0;i<trs.size();i++)
			{
				if (trs[i].immediate)
				{
					for (size_t secondary : secondaries.true_idxs())
					{
						for (transition_t& s_tr : states[secondary].transitions)
						{
							if (s_tr.bytes.any())
								dat.found_secondary_longer = true;
						}
					}
					if (i >= 1 && !trs[i-1].immediate)
					{
						dat.found_secondary_shorter = true;
					}
				}
				else
				{
					bitarray new_secondaries;
					new_secondaries.resize(states.size());
					for (transition_t& tr : trs.skip(i+1))
					{
						if ((trs[i].bytes & tr.bytes).any())
							new_secondaries[tr.target] = true;
					}
					for (size_t secondary : secondaries.true_idxs())
					{
						for (transition_t& tr : states[secondary].transitions)
						{
							if ((trs[i].bytes & tr.bytes).any())
								new_secondaries[tr.target] = true;
						}
						if (states[primary].accepts_sequel && states[secondary].accepting)
						{
							dat.found_secondary_shorter = true;
						}
					}
					set_ordering_recurse(dat, trs[i].target, std::move(new_secondaries));
					if (i >= 1 && trs[i-1].immediate)
					{
						dat.found_secondary_longer = true;
					}
				}
			}
		}
	public:
		bool set_ordering()
		{
			ordering_data dat;
			dat.visited_primaries.resize(states.size());
			dat.visited_secondaries.resize(states.size());
			for (size_t i=0;i<states.size();i++)
				dat.visited_secondaries[i].resize(states.size());
			set_ordering_recurse(dat, 0, {});
			
			if (dat.found_secondary_shorter && dat.found_secondary_longer)
				return false;
			
			// if both are legal, prefer shortest first
			shortest_first = !dat.found_secondary_shorter;
			return true;
		}
		
	public:
		insntype_t convert_to_dfa(dfa_t& dfa)
		{
			// straightforward version:
			//unique_bytes[0] = true;
			//for (state_t& st : states)
			//for (transition_t& tr : st.transitions)
			//{
			//	for (size_t i=1;i<256;i++)
			//	{
			//		if (tr.bytes.get(i) != tr.bytes.get(i-1))
			//			unique_bytes[i] = true;
			//	}
			//}
			
			uint32_t ret[8] = { 1, 0, 0, 0, 0, 0, 0, 0 };
			static_assert(sizeof(unique_bytes) == sizeof(ret));
			
			for (state_t& st : states)
			for (transition_t& tr : st.transitions)
			{
				uint32_t tmp[8];
				memcpy(tmp, &tr.bytes, sizeof(tmp));
				ret[0] |= tmp[0] ^ (tmp[0]<<1);
				for (int i=1;i<8;i++)
					ret[i] |= tmp[i] ^ ((tmp[i]<<1) | (tmp[i-1]>>31));
			}
			memcpy(&unique_bytes, ret, sizeof(ret));
			
			map<bitarray, uint32_t> seen;
			fifo<bitarray> convert_to_dfa_todo;
			
			bitarray in_states;
			in_states.resize(states.size());
			in_states[0] = true;
			convert_to_dfa_todo.push(in_states);
			seen.get_create(in_states, 0);
			
			while (!convert_to_dfa_todo.empty())
			{
				in_states = convert_to_dfa_todo.pop();
				size_t n_set = 0;
				uint32_t next_state KNOWN_INIT(0);
				dfa_t::node_t& node = dfa.transitions.append();
				
				for (size_t by : unique_bytes.true_idxs())
				{
					while (n_set < by)
						node.next[n_set++] = next_state;
					
					bitarray new_states;
					new_states.resize(states.size());
					bool any = false;
					bool accepting = false;
					
					for (size_t i : in_states.true_idxs())
					{
						for (transition_t& tr : states[i].transitions)
						{
							if (tr.bytes[by])
							{
								if (states[tr.target].accepting)
									accepting = true;
								if (states[tr.target].accepts_sequel)
								{
									new_states[tr.target] = true;
									any = true;
								}
							}
						}
					}
					if (any)
					{
						uint32_t create_state = seen.size();
						next_state = seen.get_create(new_states, create_state);
						if (next_state == create_state)
						{
							convert_to_dfa_todo.push(new_states);
						}
					}
					else
						next_state = 0x7FFFFFFF;
					if (accepting)
						next_state |= 0x80000000;
				}
				while (n_set < 256)
					node.next[n_set++] = next_state;
			}
			dfa.init_state = states[0].accepting ? 0x80000000 : 0;
			deduplicate_dfa(dfa);
			return shortest_first ? t_dfa_shortest : t_dfa_longest;
		}
		
	private:
		static void deduplicate_dfa(dfa_t& dfa)
		{
			// if some nfa states are functionally identical (for example in a*a*), then there may be duplicate DFA states
			// the states are hard to identify as duplicate at NFA level (for example, state transition order can vary),
			// but they show up as identical in the DFA
			map<dfa_t::node_t, size_t> first_body; // rhs is index in dfa.transitions
			map<size_t, size_t> replacements;
			for (size_t i=0;i<dfa.transitions.size();i++)
			{
				size_t n = first_body.get_create(dfa.transitions[i], i);
				if (i != n)
					replacements.insert(i, n);
			}
			if (replacements.size() == 0)
				return;
			
			array<uint32_t> new_ids;
			new_ids.resize(dfa.transitions.size());
			size_t num_valid_states = 0;
			for (size_t i=0;i<dfa.transitions.size();i++)
			{
				if (replacements.contains(i))
					new_ids[i] = new_ids[replacements.get(i)];
				else
					new_ids[i] = num_valid_states++;
			}
			size_t i = dfa.transitions.size();
			while (true)
			{
				if (!i)
					break;
				i--;
				if (replacements.contains((size_t)i))
				{
					dfa.transitions.remove(i);
				}
				else
				{
					for (uint32_t& tr : dfa.transitions[i].next)
					{
						uint32_t accept = (tr & 0x80000000);
						uint32_t st = (tr & 0x7FFFFFFF);
						if (st != 0x7FFFFFFF)
							tr = accept | new_ids[st];
					}
				}
			}
		}
		
	private:
	public:
#ifndef _WIN32 // todo: enable these when my compiler shuts up about %zu
		void dump() const
		{
			for (size_t i=0;i<states.size();i++)
			{
				printf("state %zu: ", i);
				if (i == 1)
				{
					puts("accepting");
					continue;
				}
				if (states[i].deleted)
				{
					puts("deleted");
					continue;
				}
				arrayview<transition_t> trs = states[i].transitions;
				for (size_t j=0;j<trs.size();j++)
				{
					if (j >= 1) printf(", ");
					if (trs[j].immediate)
						printf("(immediate)");
					else
						dump_byte(trs[j].bytes);
					printf(" -> %u", trs[j].target);
				}
				puts("");
			}
			if (shortest_first)
				puts("shortest first");
			else
				puts("longest first");
		}
#endif
	};
	
	
	size_t try_convert_sequence_to_nfa(node_t& node, size_t start, size_t end)
	{
		if (start+1 == end)
		{
			try_convert_node_to_nfa(node.children[start]);
			return end;
		}
		
		nfa_t nfa;
		nfa.create(rgx, node.children.slice(start, end-start), node.type==n_alternative);
		
		if (nfa.set_ordering())
		{
			while (end-1 > start)
			{
				node.children.remove(end-1);
				end--;
			}
			uint32_t idx = rgx->dfas.size();
			insntype_t insn = nfa.convert_to_dfa(rgx->dfas.append());
			node.children[start] = { n_insn, { insn, idx } };
		}
		else
		{
			// if converting that fragment to NFA is ambiguous, delete the last node and try again
			try_convert_node_to_nfa(node.children[end-1]);
			return try_convert_sequence_to_nfa(node, start, end-1) + 1;
		}
		return end;
	}
	void try_convert_node_to_nfa(node_t& node)
	{
		if (node.type == n_insn)
		{
			for (node_t& ch : node.children)
				try_convert_node_to_nfa(ch);
			// if it's a byte instruction, just leave it
		}
		else
		{
			size_t start = 0;
			while (true)
			{
				while (start < node.children.size() && !node.children[start].can_nfa)
				{
					try_convert_node_to_nfa(node.children[start]);
					start++;
				}
				if (start == node.children.size())
					break;
				size_t end = start;
				while (end < node.children.size() && node.children[end].can_nfa)
					end++;
				
				start = try_convert_sequence_to_nfa(node, start, end);
			}
		}
	}
	
	void optimize_to_nfas(node_t& node)
	{
		nfa_t::tag_can_nfa(node);
		try_convert_node_to_nfa(node);
	}
	
	// Ignores repeat count.
	void to_insns_single(node_t& node)
	{
		if (node.type == n_series)
		{
			for (node_t& n : node.children)
				to_insns(n);
		}
		if (node.type == n_alternative)
		{
			size_t prev_start = 0;
			for (size_t i=0;i<node.children.size();i++)
			{
				node_t& n = node.children[i];
				bool first = (i == 0);
				bool last = (i == node.children.size()-1);
				
				size_t start = rgx->insns.size();
				if (!last)
					rgx->insns.append({ t_alternative_second });
				to_insns(n);
				if (prev_start)
					rgx->insns[prev_start].data = rgx->insns.size();
				if (!last)
				{
					prev_start = rgx->insns.size();
					rgx->insns.append({ t_jump });
					rgx->insns[start].data = rgx->insns.size();
				}
			}
		}
		if (node.type == n_insn)
		{
			if (node.children)
			{
				size_t start = rgx->insns.size();
				rgx->insns.append(node.subtype);
				for (node_t& n : node.children)
					to_insns(n);
				rgx->insns.append({ t_accept, node.subtype.type });
				rgx->insns[start].data = rgx->insns.size();
			}
			else
				rgx->insns.append(node.subtype);
		}
	}
	// Handles repeat count.
	void to_insns(node_t& node)
	{
		if (LIKELY(!node.has_repeat))
			return to_insns_single(node);
		
		size_t the_infinite_one = (node.repeat_infinite ? node.num_total_bodies-1 : SIZE_MAX);
		
		for (size_t i=0;i<node.num_total_bodies;i++)
		{
			if (i >= node.num_mandatory_bodies)
				rgx->insns.append(); // placeholder
			size_t insns_start = rgx->insns.size();
			to_insns_single(node);
			
			if (i == the_infinite_one)
				rgx->insns.append({ node.greedy ? t_alternative_first : t_alternative_second, (uint32_t)insns_start });
			if (i >= node.num_mandatory_bodies)
				rgx->insns[insns_start-1] = { node.greedy ? t_alternative_second : t_alternative_first, (uint32_t)rgx->insns.size() };
		}
	}
	
public:
	bool parse(const uint8_t * start, node_t& target)
	{
		rgx->reset();
		rgx->num_captures = 1;
		
		const uint8_t * at = parse_disjunction(target, start);
		if (at != end)
		{
			rgx->set_fail();
			return false;
		}
		return true;
	}
public:
	static bool compile(regex* rgx, cstring text)
	{
		parser p { rgx, (uint8_t*)text.ptr_raw_end() };
		node_t target;
		if (!p.parse(text.bytes().ptr(), target))
			return false;
		
		p.optimize_to_nfas(target);
		
		p.to_insns(target);
		rgx->insns.append({ t_accept, t_accept });
		return true;
	}
	
private:
	void dump(const node_t& node) const { dump(rgx, node); }
	static void dump(regex* rgx, const node_t& node)
	{
		if (node.has_repeat)
		{
			printf("repeat (%u bodies, %u mandatory, %sfinite, %s) ",
			       node.num_total_bodies, node.num_mandatory_bodies, node.repeat_infinite ? "in" : "",
			       node.greedy ? "greedy" : "lazy");
		}
		if (node.type == n_insn)
			printf("insn %s", insn_names[node.subtype.type]);
		else
			printf("%s", node.type==n_series ? "series" : "alternative");
		if (node.type == n_insn && node.subtype.type == t_byte)
		{
			printf(" ");
			dump_byte(rgx->bytes[node.subtype.data]);
		}
		if (node.children)
		{
			printf(" {\n");
			for (const node_t& ch : node.children)
			{
				dump(rgx, ch);
			}
			printf("}");
		}
		printf("\n");
	}
};

bool regex::parse(cstring rgx)
{
	if (parser::compile(this, rgx))
	{
		optimize();
		return true;
	}
	else
	{
		set_fail();
		return false;
	}
}

void regex::optimize()
{
	bool again = true;
	while (again)
	{
		again = false;
		for (size_t i=0;i<insns.size();i++)
		{
			if (insns[i].type == t_jump && (insns[insns[i].data].type == t_jump || insns[insns[i].data].type == t_accept))
			{
				insns[i] = insns[insns[i].data];
				again = true;
			}
			else if (targets_another_insn(insns[i].type) && insns[insns[i].data].type == t_jump)
			{
				// parser doesn't emit alt/lookaround to jump, but why not
				insns[i].data = insns[insns[i].data].data;
				again = true;
			}
		}
	}
	
	// doubt this does anything, but it's harmless. Reduces memory use a little, I guess
	array<bitset<256>> new_bytes;
	for (size_t i=0;i<insns.size();i++)
	{
		if (insns[i].type == t_byte)
		{
			size_t idx = new_bytes.find(bytes[insns[i].data]);
			if (idx == (size_t)-1)
			{
				idx = new_bytes.size();
				new_bytes.append(bytes[insns[i].data]);
			}
			insns[i].data = idx;
		}
	}
	bytes = std::move(new_bytes);
	
	// rejected optimizations:
	// - delete unreachable instructions, after byte(none) or if only reachable by jump
	//     byte(none) is ultra rare, and jumps only come from | where the target is after the last branch, so no point
	// - deduplicate bytes in NFAs/DFAs; have a 256-byte table for each FA and shrink the transition tables to max(256b-table)+1
	//     probably helps NFAs, but not DFAs, and I never emit NFA instructions
	// - compress small NFAs to uint8
	//     tried it, gives a ~6% slowdown
}

class regex::matcher {
public:
	const regex * parent;
	const uint8_t * start;
	const uint8_t * end;
	
	regex::pair* result;
	
#ifdef ARLIB_OPT
	forceinline // if unoptimized, it won't understand that the recursion is actually tail calls
#endif
	bool match(checktype_t ty, uint32_t state, const uint8_t * at, size_t extra)
	{
		auto[type, data] = parent->insns[state];
		switch (ty)
		{
		case ct_jump:
			break;
		case ct_dfa_shortest:
			goto cont_dfa_shortest;
		case ct_dfa_longest:
			goto cont_dfa_longest;
		case ct_setcapture_start:
			goto cont_setcapture_start;
		case ct_setcapture_end:
			goto cont_setcapture_end;
		case ct_lookahead_pos:
			return false;
		case ct_lookahead_neg:
			break;
		default: __builtin_unreachable();
		}
		while (true)
		{
			switch (type)
			{
			case t_jump:
				state = data;
				break;
			case t_accept:
				if (data == t_accept)
				{
					result[0].end = (char*)at;
					return true;
				}
				if (data == t_lookahead_positive)
				{
					while (true)
					{
						auto pt = parent->checkpoints.pop();
						if (pt.ty == ct_lookahead_pos)
							return match(ct_jump, pt.state, pt.at, 0);
					}
				}
				if (data == t_lookahead_negative)
				{
					while (true)
					{
						auto pt = parent->checkpoints.pop();
						if (pt.ty == ct_lookahead_neg)
							return false;
					}
				}
				__builtin_unreachable();
			case t_alternative_first:
				parent->checkpoints.push({ ct_jump, state+1, at, 0 });
				return match(ct_jump, data, at, 0);
			case t_alternative_second:
				parent->checkpoints.push({ ct_jump, data, at, 0 });
				return match(ct_jump, state+1, at, 0);
			
			case t_byte:
				if (at == end)
					return false;
				if (!parent->bytes[data][*at++])
					return false;
				state++;
				break;
			
			case t_dfa_shortest:
			{
				const dfa_t* dfa;
				dfa = &parent->dfas[data];
				uint32_t dfa_state;
				dfa_state = dfa->init_state;
				while (true)
				{
					if (dfa_state & 0x80000000)
					{
						extra = dfa_state & 0x7FFFFFFF;
						parent->checkpoints.push({ ct_dfa_shortest, state, at, extra });
						return match(ct_jump, state+1, at, 0);
					cont_dfa_shortest:
						dfa = &parent->dfas[data];
						dfa_state = extra;
					}
					if (dfa_state == 0x7FFFFFFF || at == end)
						return false;
					
					dfa_state = dfa->transitions[dfa_state].next[*at++];
				}
			}
			case t_dfa_longest:
			{
				{
					const dfa_t& dfa = parent->dfas[data];
					uint32_t dfa_state = dfa.init_state;
					extra = at-start;
					while (true)
					{
						parent->dfa_matches.set(at-start, (dfa_state & 0x80000000));
						dfa_state &= 0x7FFFFFFF;
						if (dfa_state == 0x7FFFFFFF || at == end)
							break;
						dfa_state = dfa.transitions[dfa_state].next[*at++];
					}
				}
				while (at >= start+extra)
				{
					if (parent->dfa_matches.get(at-start))
					{
						parent->checkpoints.push({ ct_dfa_longest, state, at, extra });
						return match(ct_jump, state+1, at, 0);
					cont_dfa_longest: ;
					}
					at--;
				}
				return false;
			}
			
			case t_capture_start:
			{
				parent->checkpoints.push({ ct_setcapture_start, state, at, (size_t)result[data].start });
				result[data].start = (char*)at;
				return match(ct_jump, state+1, at, 0);
			cont_setcapture_start:
				result[data].start = (char*)extra;
				return false;
			}
			case t_capture_end:
			{
				parent->checkpoints.push({ ct_setcapture_end, state, at, (size_t)result[data].end });
				result[data].end = (char*)at;
				return match(ct_jump, state+1, at, 0);
			cont_setcapture_end:
				result[data].end = (char*)extra;
				return false;
			}
			case t_capture_discard:
			{
				if (result[data].start)
				{
					parent->checkpoints.push({ ct_setcapture_start, state, at, (size_t)result[data].start });
					parent->checkpoints.push({ ct_setcapture_end, state, at, (size_t)result[data].end });
					result[data].start = nullptr;
					result[data].end = nullptr;
				}
				return match(ct_jump, state+1, at, 0);
			}
			case t_capture_backref:
			{
				size_t len = result[data].end - result[data].start;
#ifdef ARLIB_TESTRUNNER
				assert_lt(len, SIZE_MAX/2);
#endif
				if (at+len > end)
					return false;
				if (memcmp(at, result[data].start, len) != 0)
					return false;
				at += len;
				state++;
				break;
			}
			
			case t_assert_boundary:
			case t_assert_notboundary:
			{
				uint8_t prev = (at == start ? '\0' : at[-1]);
				uint8_t next = (at == end ? '\0' : at[0]);
				auto chs = CHAR_SET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_");
				if ((chs.contains(prev) == chs.contains(next)) == (type == t_assert_boundary))
					return false;
				state++;
				break;
			}
			case t_assert_start:
				if (at != start)
					return false;
				state++;
				break;
			case t_assert_end:
				if (at != end)
					return false;
				state++;
				break;
			
			case t_lookahead_positive:
				parent->checkpoints.push({ ct_lookahead_pos, data, at, 0 });
				return match(ct_jump, state+1, at, 0);
			case t_lookahead_negative:
				parent->checkpoints.push({ ct_lookahead_neg, data, at, 0 });
				return match(ct_jump, state+1, at, 0);
			
			default: __builtin_unreachable();
			}
			type = parent->insns[state].type;
			data = parent->insns[state].data;
		}
	}
	
	bool match_outer(const uint8_t * at)
	{
		parent->checkpoints.reset();
		size_t dfa_matches_size = end-start+1;
		if (dfa_matches_size >= parent->dfa_matches.size())
			parent->dfa_matches.resize(end-start+1);
		checkpoint_t pt = { ct_jump, 0, at, 0 };
		while (true)
		{
			if (match(pt.ty, pt.state, pt.at, pt.extra))
				return true;
			if (!parent->checkpoints)
				return false;
			pt = parent->checkpoints.pop();
		}
	}
};

void regex::match(pair* ret, const char * start, const char * at, const char * end) const
{
	ret[0].start = at;
	matcher m { this, (uint8_t*)start, (uint8_t*)end, ret };
	if (!m.match_outer((uint8_t*)at))
	{
		// must wipe everything, not just result[0], to avoid bugs where (?!(a)) + "a" leaves trash
		memset(ret, 0, sizeof(pair)*num_captures);
	}
}

void regex::match_alloc(size_t num_captures, pair* ret, const char * start, const char * at, const char * end) const
{
	array<pair> ret2;
	ret2.resize(this->num_captures);
	match(ret2.ptr(), start, at, end);
	memcpy(ret, ret2.ptr(), sizeof(pair)*num_captures);
}

string regex::replace(cstring str, const char * replacement) const
{
	pair store1[5] = {};
	array<pair> store2;
	
	const char * start = str.ptr_raw();
	const char * end = str.ptr_raw_end();
	matcher m { this, (uint8_t*)start, (uint8_t*)end, store1 };
	if (num_captures > 5)
	{
		store2.resize(num_captures);
		m.result = store2.ptr();
	}
	
	string out;
	
	const char * iter = start;
	while (iter < end)
	{
		if (m.match_outer((uint8_t*)iter) && m.result[0].end > iter)
		{
			for (size_t i=0;replacement[i];i++)
			{
				if (replacement[i] == '\\')
				{
					int n = replacement[i+1]-'0';
					if (n < 0 || n > 9) abort();
					
					out += m.result[n].str();
					i++;
				}
				else
					out += replacement[i];
			}
			iter = m.result[0].end;
		}
		else
		{
			out += *iter;
			iter++;
		} 
	}
	return out;
}

template<typename T> // T = regex::parser::node_t, it's a template because can't name regex::parser::anything in header
void regex::required_substrs_recurse(regex* rgx, T& node, array<string>& ret)
{
#ifndef ARLIB_OPT
	if (node.type != parser::n_series)
		abort();
#endif
	
	string* str = nullptr;
	for (parser::node_t& ch : node.children)
	{
		if (ch.type == parser::n_insn && ch.subtype.type == t_byte && !ch.has_repeat)
		{
			const bitset<256>& by = rgx->bytes[ch.subtype.data];
			auto it = by.true_idxs().begin();
			if (it != end_iterator{})
			{
				uint8_t by = *it;
				++it;
				if (!(it != end_iterator{}))
				{
					if (!str)
						str = &ret.append();
					*str += by;
					continue;
				}
			}
		}
		str = nullptr;
		
		if (ch.type == parser::n_series && !ch.has_repeat)
			regex::required_substrs_recurse(rgx, ch, ret);
	}
}

array<string> regex::required_substrs(cstring rgx)
{
	regex r;
	regex::parser p { &r, (uint8_t*)rgx.ptr_raw_end() };
	regex::parser::node_t target;
	if (!p.parse(rgx.bytes().ptr(), target))
		return {};
	
	array<string> ret;
	if (target.type == regex::parser::n_series) // can be n_alternative
		regex::required_substrs_recurse(&r, target, ret);
	return ret;
}


bool regex_search::parse(cstring rgx)
{
	set_fail();
	
	regex r;
	regex::parser p { &r, (uint8_t*)rgx.ptr_raw_end() };
	regex::parser::node_t node;
	if (!p.parse(rgx.bytes().ptr(), node))
		return false;
	
	if (!regex::parser::nfa_t::tag_can_nfa(node))
		return false;
	
#ifndef ARLIB_OPT
	if (node.type == regex::parser::n_insn)
		abort();
#endif
	
	regex::parser::nfa_t nfa;
	nfa.shortest_first = false; // valgrind complains if I don't set this
	nfa.create(&r, node.children, node.type==regex::parser::n_alternative);
	regex::dfa_t dfa;
	nfa.convert_to_dfa(dfa);
	
	int num_unroll = 4; // todo: find better value, or auto tune it
	accept_empty = (dfa.init_state & 0x80000000);
	unroll_count = num_unroll;
	
	array<int32_t> states;
	states.resize(num_unroll);
	size_t target = 0;
	for (int i=1;i<num_unroll;i++)
	{
		states[i] = dfa.transitions.size();
		regex::dfa_t::node_t& n = dfa.transitions.append();
		for (int j=0;j<256;j++) 
			n.next[j] = target;
		target = states[i];
	}
	
	map<array<int32_t>, uint16_t, arrayview_hasher> seen;
	transitions.reset();
	state_for_recurse(nfa.unique_bytes, dfa, seen, states);
	if (transitions.size() > 65535)
	{
		// too complex, ask for a lower num_unroll
		set_fail();
		return false;
	}
	
	return true;
}
uint16_t regex_search::state_for_recurse(const bitset<256>& unique_bytes, const regex::dfa_t& dfa,
                                         map<array<int32_t>, uint16_t, arrayview_hasher>& seen, arrayview<int32_t> in_states)
{
	uint32_t create_state = seen.size();
	uint32_t dfa_state = seen.get_create(in_states, create_state);
	if (dfa_state == create_state)
	{
		transitions.append();
		
		size_t n_set = 0;
		next_t next_state KNOWN_INIT({});
		
		for (size_t by : unique_bytes.true_idxs())
		{
			while (n_set < by)
				transitions[dfa_state].next[n_set++] = next_state;
			
			uint8_t lowest_possible = 0xFF;
			uint8_t lowest_match = 0xFF;
			
			array<int32_t> new_states;
			new_states.resize(in_states.size());
			
			for (size_t i=0;i<in_states.size();i++)
			{
				if (in_states[i] < 0)
				{
					new_states[i] = -1;
					continue;
				}
				uint32_t dfa_next = dfa.transitions[in_states[i]].next[by];
				if (dfa_next & 0x80000000)
				{
					if (lowest_match == 0xFF)
						lowest_match = i;
					new_states[i] = -1; // drop it after first match, anything beyond that can't affect anything
				}
				else
				{
					new_states[i] = dfa_next;
					if (new_states[i] == 0x7FFFFFFF)
						new_states[i] = -1;
					else if (lowest_possible == 0xFF)
						lowest_possible = i;
				}
			}
			if (lowest_possible != 0xFF)
				next_state = { lowest_possible, lowest_match, state_for_recurse(unique_bytes, dfa, seen, new_states) };
			else
				next_state = { 0xFF, lowest_match };
		}
		while (n_set < 256)
			transitions[dfa_state].next[n_set++] = next_state;
	}
	return dfa_state;
}

const char * regex_search::search(const char * start, const char * end) const
{
	if (accept_empty)
		return start;
	while (true)
	{
		uint32_t best_match = 0xFF;
		const char * iter = start;
		uint32_t state = 0;
		while (iter < end)
		{
			uint8_t ch = (uint8_t)*iter++;
			const next_t& next = transitions[state].next[ch];
			if (next.lowest_match < best_match)
				best_match = next.lowest_match;
			if (best_match <= next.lowest_possible)
				break;
			state = next.next;
		}
		if (best_match != 0xFF)
			return start + best_match;
		
		if (end-start < unroll_count)
			return nullptr;
		start += unroll_count;
	}
}

#ifndef _WIN32 // todo: enable these when my compiler shuts up about %zu
void regex_search::dump() const
{
	printf("unroll count %d\n", unroll_count);
	if (accept_empty) puts("accept empty");
	for (size_t st=0;st<transitions.size();st++)
	{
		const node_t& n = transitions[st];
		printf("  %zu: ", st);
		for (size_t by=0;by<256;by++)
		{
			size_t by1 = by;
			while (by+1 < 256 && n.next[by+1] == n.next[by])
				by++;
			regex::dump_range(by1, by);
			
			printf(" -> %d,%d,%d", n.next[by].lowest_possible, n.next[by].lowest_match, n.next[by].next);
			if (by != 255)
				printf(", ");
		}
		puts("");
	}
}

void regex::dump(arrayview<insn_t> insns) const
{
	for (size_t i=0;i<insns.size();i++)
	{
		auto[type, data] = insns[i];
		printf("%zu %s %u", i, insn_names[type], data);
		if (type == t_byte)
		{
			printf(" ");
			dump_byte(bytes[data]);
		}
		puts("");
		if (type == t_dfa_shortest || type == t_dfa_longest)
			dfas[data].dump();
	}
}
void regex::dfa_t::dump() const
{
	if (init_state & 0x80000000)
		puts("  accepts empty");
	for (size_t st=0;st<transitions.size();st++)
	{
		const dfa_t::node_t& n = transitions[st];
		printf("  %zu: ", st);
		for (size_t by=0;by<256;by++)
		{
			size_t by1 = by;
			while (by+1 < 256 && n.next[by+1] == n.next[by])
				by++;
			dump_range(by1, by);
			
			uint32_t next_st_raw = n.next[by];
			int32_t next_st = next_st_raw & 0x7FFFFFFF;
			if (next_st == 0x7FFFFFFF)
				next_st = -1;
			printf(" -> %s%d", (next_st_raw&0x80000000) ? "A " : "", next_st);
			if (by != 255)
				printf(", ");
		}
		puts("");
	}
}
#endif
void regex::dump_byte(const bitset<256>& byte)
{
	int first_true = -1;
	for (int i=0;i<=256;i++)
	{
		if (i<256 && byte[i])
		{
			if (first_true == -1)
				first_true = i;
		}
		else
		{
			if (first_true != -1)
				dump_range(first_true, i-1);
			first_true = -1;
		}
	}
}
void regex::dump_range(uint8_t first, uint8_t last)
{
	if (last-first <= 3)
	{
		for (int i=first;i<=last;i++)
			dump_single_char(i);
	}
	else
	{
		dump_single_char(first);
		printf("-");
		dump_single_char(last);
	}
}
void regex::dump_single_char(uint8_t ch)
{
	if (ch <= ' ' || ch >= '\x7F' || ch == '-')
		printf("\\x%.2X", ch);
	else
		printf("%c", ch);
}
