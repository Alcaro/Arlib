#!/usr/bin/env python3

import os, struct, zlib

# silly tricks so __pycache__ goes away
# why is there no programmatic control over that thing, other than setting an env and reexecing? why is it not a dotfile?
# why does it even exist? no other scripting language I'm aware of caches the compiled form to disk
__name__ = "not __main__"
exec(open(os.path.dirname(__file__)+"/redeflate.py","rt").read())
#from redeflate import deflate_slow

use_incbin = True  # Massively speeds up compile time if resources are big, but may reduce portability.
# use_incbin = False  # TODO: autodetect target output format, disable if not GCC
# TODO: more std::embed, once it exists

header_early = '// Autogenerated, do not edit. All changes will be undone.\n'
body_early = header_early
w32_res = header_early

header_early += '#pragma once\n#include "../arlib/global.h"\n'
header = 'namespace resources {\nvoid init();\n'
body_early += '#include "resources.h"\nnamespace resources {\n'
body = ""
body_late = ""
constructor = ""
constructor_late = ""
asm = ""

if use_incbin:
	body += r"""
#  define ASM_DATA(text) __asm__(".data\n" text ".text\n")
#if defined(__unix__)
#  define ASM_RODATA(text) \
     __asm__(".section .rodata,\"a\",@progbits\n" text ".text\n")
#  define ASM_LABEL(varname, size) \
     ".globl " varname "\n" \
     ".size " varname ", " STR(size) "\n" \
     ".type " varname ", @object\n" \
     varname ":\n"
#endif
#if defined(_WIN32)
#  define ASM_RODATA(text) __asm__(".section .rdata,\"dr\"\n" text ".text\n")
#  if defined(__i386__)
#    define ASM_LABEL(varname, size) "_" varname ":\n"
#  else
#    define ASM_LABEL(varname, size) varname ":\n"
#  endif
#endif


#if UINTPTR_MAX == UINT64_MAX
#  define ASM_POINTER ".quad "
#  define ASM_POINTER_SIZE 8
#else
#  define ASM_POINTER ".int "
#  define ASM_POINTER_SIZE 4
#endif

#  define ASM_INCLUDE_LIST(text) ASM_RODATA(text)
#  define ASM_INCLUDE(varname, size, filename) \
     ASM_LABEL(varname, size) \
     ".incbin \"" filename "\"\n"
"""


def asmmangle(name): return "_ZN9resources"+str(len(name))+name+"E"


icon_names = {}  # { 0: "minir" } (0 is exe's icon, others are usable for file associations)
icon_paths = {}  # { 0: { 48: "resources/minir.icon-48.png", 32: etc, 16: etc } }

for fn in sorted(os.listdir("resources/")):
	if fn.startswith("x-"): continue
	fullfn = "resources/"+fn
	filesize = os.path.getsize(fullfn)
	
	# split on first period, not last, so 'monospace.font.png' becomes item 'monospace' of extension 'font.png'
	sfn,ext = fn.split(".",1)
	sfn = sfn
	
	varname = sfn.replace("-","_")
	varname_raw = varname+"_raw"
	
	file_bytes = None
	raw_private = False
	
	if 0: 1/0
	elif ext == "png":
		header += "extern oimage "+varname+";\n"
		body += "oimage "+varname+";\n"
		constructor += varname+" = oimage::decode_png("+varname_raw+");\n"
	elif ext == "jpg":
		# init_decode_jpg doesn't exist, but...
		header += "image "+varname+";\n"
		constructor += varname+" = oimage::decode_jpg("+varname_raw+");\n"
	elif ext == "bin" or ext.startswith("raw."):
		varname_raw = varname
	elif ext == "cpp":
		with open(fullfn, "rt") as f:
			text = f.read()
		fullfn = None
		parts = text.split("//@")
		if parts[0]: 1/0
		for part in parts[1:]:
			ty,text = part.split("\n",1)
			ty = ty.strip()
			if ty == "header":
				for line in text.split("\n"):
					if not line: continue
					if line[0] == '#': header_early += line+"\n"
					else: header += line+"\n"
			elif ty == "body":
				body_late += text
			elif ty == "constructor":
				constructor_late += "{\n"+text+"}\n"
			else:
				1/0
	elif ext.startswith("icon"):
		if not ext.endswith(".png"): 1/0
		# minir.icon2-48.png
		icoid,icosize = ext[4:].split("-")
		icoid = int("0"+icoid) # "0"+ so blank becomes 0
		icosize = int(icosize.rsplit(".",1)[0])
		
		if icoid in icon_names:
			assert(sfn == icon_names[icoid])
		else:
			icon_names[icoid] = sfn
			icon_paths[icoid] = {}
		icon_paths[icoid][icosize] = fullfn
		
		continue
	else:
		print("Unknown file type "+ext)
		1/0
	
	
	if fullfn is None:
		continue
	
	if file_bytes is not None:
		fullfn = "obj/resource-"+varname+".bin"
		with open(fullfn,"wb") as f: f.write(file_bytes)
		filesize = len(file_bytes)
	
	if use_incbin:
		asm += 'ASM_INCLUDE("'+asmmangle(varname_raw)+'", '+str(filesize)+', "'+fullfn+'")\n'
	else:
		with open(fullfn, "rb") as f:
			b = f.read()
			body += "extern const uint8_t "+varname_raw+"["+str(len(b))+"] = { "
			body += ",".join(str(n) for n in b)
			body += " };\n"
	
	header += "extern const uint8_t "+varname_raw+"["+str(filesize)+"];\n"

header = header_early + header + "}\n"
if constructor:
	constructor = "RUN_ONCE_FN(init_inner)\n{\n" + constructor + constructor_late + "}\n"
	constructor += "void init() { init_inner(); }\n"
body = body_early + body + body_late + constructor + "}\n"

if use_incbin and asm: body += 'ASM_INCLUDE_LIST(\n'+asm+');\n'

# PNG-style .ico requires Vista or higher, but BMP-style requires messing with PIL or zlib (and BMP is bigger), so let's just use PNG
# (also not supported in GdkPixbuf, though Wine supports it since 2010. https://github.com/wine-mirror/wine/commit/666940902db2c693
#    https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/issues/16 https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/blob/master/gdk-pixbuf/io-ico.c)
def make_ico(pngs, convert_to_bmp=False):
	for png in pngs:
		assert png[:16] == b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR"
	# I can't find a spec for what order to use; I'll pick ascending, it seems more common
	pngs = sorted(pngs, key=(lambda png: png[16:24]))  # width/height from the IHDR
	
	ico_head = struct.pack("<HHH", 0, 1, len(pngs))
	ico_body = bytearray()
	ico_head_size = 6+16*len(pngs)
	
	for png in pngs:
		w,h = struct.unpack(">II", png[16:24])
		assert w <= 256
		assert h <= 256
		if (w > 48 or h > 48) and convert_to_bmp:
			# from what I can google, XP doesn't use icons bigger than 48x48, so bigger ones can safely be png
			# (though XP may misbehave if a window icon is PNG, it's unclear. May depend on whether the ico contains multiple sizes.)
			1/0
			# todo: implement
			# format is somewhat documented at
			# https://devblogs.microsoft.com/oldnewthing/20101018-00/?p=12513
			# https://devblogs.microsoft.com/oldnewthing/20101019-00/?p=12503
			# https://devblogs.microsoft.com/oldnewthing/20101021-00/?p=12483
			# https://devblogs.microsoft.com/oldnewthing/20101022-00/?p=12473
			# https://en.wikipedia.org/wiki/ICO_(file_format)
			# https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/blob/master/gdk-pixbuf/io-ico.c
			# with various sample files found at
			# https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/issues/16#note_181162
		else:
			img = png
		ico_head += struct.pack("<BBBBHHII", w&255, h&255, 0, 0, 1, 0, len(img), ico_head_size+len(ico_body))
		ico_body += img
	return ico_head + ico_body

for icoid in sorted(icon_paths):
	w32_res += str(icoid)+' ICON DISCARDABLE "obj/ico'+str(icoid)+'.ico"\n'
	with open('obj/ico'+str(icoid)+'.ico',"wb") as f:
		f.write(make_ico([open(fn,"rb").read() for fn in icon_paths[icoid].values()]))

with open("obj/resources.h", "wt") as f: f.write(header)
with open("obj/resources.cpp", "wt") as f: f.write(body)
with open("obj/icons.rc", "wt") as f: f.write(w32_res)
